---
# Thanos Object Storage Secret
# Uses External Secrets Operator to fetch S3 credentials from AWS Secrets Manager
#
# Prerequisites:
# 1. External Secrets Operator installed in cluster
# 2. AWS Secrets Manager secret created with S3 bucket config
# 3. IRSA configured for external-secrets ServiceAccount
#
# Alternative: Use IRSA directly on Thanos pods (recommended)
# This secret is only needed if NOT using IRSA

apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: thanos-objstore-secret
  namespace: monitoring
  labels:
    app.kubernetes.io/name: thanos
    app.kubernetes.io/component: objstore
spec:
  # Refresh secret every 1 hour
  refreshInterval: 1h

  # SecretStore reference (cluster-scoped or namespace-scoped)
  secretStoreRef:
    name: aws-secrets-manager
    kind: ClusterSecretStore

  # Target Kubernetes secret
  target:
    name: thanos-objstore-secret
    creationPolicy: Owner
    deletionPolicy: Retain

    # Template for the secret data
    template:
      type: Opaque
      engineVersion: v2
      data:
        # objstore.yml - Thanos object storage configuration
        objstore.yml: |
          type: S3
          config:
            bucket: {{ .bucket }}
            endpoint: {{ .endpoint }}
            region: {{ .region }}
            {{- if .access_key }}
            access_key: {{ .access_key }}
            secret_key: {{ .secret_key }}
            {{- end }}
            sse_config:
              type: "SSE-S3"
            http_config:
              idle_conn_timeout: 90s
              response_header_timeout: 2m
              tls_config:
                insecure_skip_verify: false
            trace:
              enable: true
            list_objects_version: "v2"
            part_size: 134217728  # 128MB

  # Data to fetch from AWS Secrets Manager
  data:
  - secretKey: bucket
    remoteRef:
      key: thanos/objstore-config  # AWS Secrets Manager secret name
      property: bucket

  - secretKey: endpoint
    remoteRef:
      key: thanos/objstore-config
      property: endpoint

  - secretKey: region
    remoteRef:
      key: thanos/objstore-config
      property: region

  # Optional: Access key and secret key (only if NOT using IRSA)
  # - secretKey: access_key
  #   remoteRef:
  #     key: thanos/objstore-config
  #     property: access_key
  #
  # - secretKey: secret_key
  #   remoteRef:
  #     key: thanos/objstore-config
  #     property: secret_key

---
# Example: Manual Secret Creation (for testing without External Secrets)
# DO NOT use in production - use External Secrets Operator or IRSA instead
#
# apiVersion: v1
# kind: Secret
# metadata:
#   name: thanos-objstore-secret
#   namespace: monitoring
# type: Opaque
# stringData:
#   objstore.yml: |
#     type: S3
#     config:
#       bucket: "thanos-metrics-us-east-1"
#       endpoint: "s3.us-east-1.amazonaws.com"
#       region: "us-east-1"
#       # IRSA - no credentials needed
#       sse_config:
#         type: "SSE-S3"
#       http_config:
#         idle_conn_timeout: 90s
#         response_header_timeout: 2m

---
# ServiceAccount for Thanos with IRSA
# This is the RECOMMENDED approach - no credentials in secrets
#
apiVersion: v1
kind: ServiceAccount
metadata:
  name: thanos
  namespace: monitoring
  annotations:
    # IAM Role ARN with S3 access permissions
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/thanos-s3-access
  labels:
    app.kubernetes.io/name: thanos

---
# IAM Policy (Terraform/CloudFormation to create)
# This policy grants Thanos access to S3 bucket
#
# Example Terraform:
#
# resource "aws_iam_role" "thanos_s3" {
#   name = "thanos-s3-access"
#
#   assume_role_policy = jsonencode({
#     Version = "2012-10-17"
#     Statement = [{
#       Action = "sts:AssumeRoleWithWebIdentity"
#       Effect = "Allow"
#       Principal = {
#         Federated = aws_iam_openid_connect_provider.eks.arn
#       }
#       Condition = {
#         StringEquals = {
#           "${replace(aws_iam_openid_connect_provider.eks.url, "https://", "")}:sub" = "system:serviceaccount:monitoring:thanos"
#           "${replace(aws_iam_openid_connect_provider.eks.url, "https://", "")}:aud" = "sts.amazonaws.com"
#         }
#       }
#     }]
#   })
# }
#
# resource "aws_iam_role_policy" "thanos_s3" {
#   name = "thanos-s3-policy"
#   role = aws_iam_role.thanos_s3.id
#
#   policy = jsonencode({
#     Version = "2012-10-17"
#     Statement = [
#       {
#         Effect = "Allow"
#         Action = [
#           "s3:ListBucket",
#           "s3:GetBucketLocation"
#         ]
#         Resource = [
#           "arn:aws:s3:::thanos-metrics-us-east-1"
#         ]
#       },
#       {
#         Effect = "Allow"
#         Action = [
#           "s3:PutObject",
#           "s3:GetObject",
#           "s3:DeleteObject"
#         ]
#         Resource = [
#           "arn:aws:s3:::thanos-metrics-us-east-1/*"
#         ]
#       }
#     ]
#   })
# }
#
# # S3 Bucket with lifecycle policy
# resource "aws_s3_bucket" "thanos" {
#   bucket = "thanos-metrics-us-east-1"
# }
#
# resource "aws_s3_bucket_lifecycle_configuration" "thanos" {
#   bucket = aws_s3_bucket.thanos.id
#
#   rule {
#     id     = "retention"
#     status = "Enabled"
#
#     transition {
#       days          = 30
#       storage_class = "STANDARD_IA"
#     }
#
#     transition {
#       days          = 90
#       storage_class = "GLACIER_IR"
#     }
#
#     expiration {
#       days = 365
#     }
#   }
# }
